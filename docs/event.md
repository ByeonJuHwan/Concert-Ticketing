# MSA


## 트랜잭션 범위 

현재 콘서트 좌석 예약 로직에는 아래와 같습니다.
```text
--- 트랜잭션 시작 ---
회원 정보 조회
--- 락 획득 ---
좌석 조회
좌석 상태 검증
좌석 상태 변경
예약 생성
--- 락 반환 ---
--- 트랜잭션 종료 ---
```

예약에 관한 모든 로직이 하나의 트랜잭션에서 동작하므로 좌석 조회가 오래걸리거나, 상태 검증 과정의 소요시간이 오래걸릴 경우 다음과 같은 문제점이 있습니다.
- **DB 커넥션을 오래 지속하는 문제**
- **락 획득 이후 반환까지의 시간이 오래걸리는 문제**
- **비즈니스 로직간의 강한 결합**

트래픽이 적을 경우에는 큰 문제는 없지만 대용량 트래픽이 몰릴 경우 위와 같은 문제는 시스템의 성능 저하를 초래할 수 있습니다.

또 다른 예시를 들어보겠습니다.

콘서트 좌석 예약 기능에 예약한 좌석 정보를 외부 API 로 송신 해주는 기능이 추가된다고 가정해보겠습니다.


```text
기존로직
---
1. 회원 정보 조회
2. 좌석 상태 검증
3. 좌석 상태 변경
4. 예약 생성
---
기능추가
5. 좌석정보 외부 API 송신
```

외부 API로 좌석 정보를 송신하는 기능이 추가되면서, 전체 트랜잭션 시간이 4~5초로 길어집니다. 외부 API 송신은 본래의 비즈니스 로직과 직접적으로 연관이 없지만,
하나의 트랜잭션에 포함되어 있어 통신이 실패할 경우 **영향을 받지 말아야 할 비즈니스 로직까지 전체 롤백되는 문제가 발생합니다.** 
이러한 문제는 시스템의 성능과 안정성을 저하시킬 수 있습니다.

> 정리해보자면 데이터 정합성을 보장하기 위해 트랜잭션을 사용하지만, 
트랜잭션의 범위가 길어질수록 성능 저하와 시스템 병목 등의 추가 문제가 발생할 수 있습니다.

## MSA 전환

현재 좌석 예약 로직은 메인 로직과 여러 부가 로직이 결합되어 복잡성을 증가시키고 있습니다. 

메인 로직인 좌석 예약 외에도, 회원 검증, 좌석 검증, 외부 API 송신과 같은 부가 로직이 추가되면서, 
모든 로직이 하나의 트랜잭션 안에서 실행됩니다. 이로 인해 서비스가 무거워지고, 
유지보수가 어려워지는 문제가 발생하고 있습니다. 

이러한 문제를 해결하기 위해, 각 기능을 독립적인 서비스로 분리하는 MSA 를 고려해 볼 수 있습니다.

### 현 시스템의 문제점

- 비대해진 트랜잭션: 좌석 예약과 관련된 모든 로직이 하나의 트랜잭션 내에서 실행되므로, 트랜잭션의 길이가 증가하고 시스템 성능이 저하됩니다.
- 결합된 비즈니스 로직: 모든 비즈니스 로직이 단일 트랜잭션 내에 결합되어 있어, 특정 로직 변경 시 전체 시스템에 영향을 미칩니다.

#### 서비스 분리

1. User Service
	- 기능: 사용자 정보 관리 및 인증
    - 책임: 사용자 정보 조회, 사용자 상태 검증
2. Seat Service
	- 기능: 좌석 상태 관리
	- 책임: 좌석 상태 조회 및 검증, 좌석 상태 변경
3. Reservation Service
    - 기능: 예약 생성 및 관리
    - 책임: 예약 생성, 예약 상태 관리

각 서비스간의 통신은 이벤트 기반으로 `Kafka`, `RabbitMQ` 등 메시지 브로커를 통해서 통신합니다.

#### 트랜잭션 처리의 한계

각 서비스가 독립적으로 작동하므로, 전통적인 ACID 트랜잭션을 유지하기가 어렵고, 데이터 베이스도 각 서비스별로 존재하므로 
데이터 일관성 관리가 어려워집니다.

예를들면, 예약 생성시에 예외가 발생해 로직이 실패한다면 이미 커밋된 좌석 상태를 롤백시키는 동작이 필요해집니다.

#### 해결 방법

SAGA 패턴을 통해서 비즈니스 로직이 실패시 이를 롤백시키는 보상트랜잭션을 통해서 데이터 일관성을 유지할 수 있습니다.

```kotlin
@EventListener
fun handleSeatReserved(event: SeatReservedEvent) {
    try {
        reservationRepository.save(reservation) // 예약생성중 예외발생!!!
    } catch (ex: Exception) {
        // 보상 트랜잭션을 통해 좌석 상태 변경 롤백
        eventPublisher.publishEvent(ReservationCreationFailedEvent(event.seatId))
    }
}
```

MSA 로 각 서비스별로 나눔으로써 각 로직에서 필요한 관심사만 비즈니스 로직에 담을 수 있으며, 이를 통해 트랜잭션 범위를 좁게 가져감으로써 쓰레드 풀에서 사용된 쓰레드를 더 빠르게 순환시킬 수 있습니다.

그러나 서비스를 나눔으로 인해 트랜잭션의 ACID 속성을 관리하는 것이 어려워지고, 데이터베이스의 데이터 일관성을 유지하는 데에도 추가적인 노력이 필요합니다.

따라서 MSA 로 무조건 전환하기보다는 현재 비즈니스의 상황과 요구사항을 충분히 고려하여 최적의 아키텍처를 선택하는 것이 중요합니다.

이제 기존 로직에서 외부 API 와의 통신 기능을 이벤트를 발행하는 방식으로 전환해 보겠습니다.

## 이벤트 주도 설계

어플리케이션에 EVENT 를 발행 및 구독 하게 비즈니스로직을 구현한다고 하면 어떻게 활용할 수 있을까요?

- 비대해진 트랜잭션 내의 각 작업을 작은 단위의 트랜잭션으로 분리 가능합니다
- 특정 작업이 완료되었을 때, 후속 작업이 이벤트에 의해 Trigger 되도록 구성함으로써 과도하게 많은 비즈니스 로직을 알고 있을 필요가 없습니다
- 트랜잭션 내에서 외부 API 호출의 실패나 수행이 주요 비즈니스 로직에 영향을 주지 않도록 구성할 수 있습니다

그러면 이제 스프링 환경에서 이벤트를 발행함으로써 각 서비스 간의 의존도를 낮추는 방법과 작업을
외부 API 통신 이라는 기능을 추가하면서 구현해 보겠습니다.

### EventPublisher

스프링에서는 `ApplicationEventPublisher` 를 사용해서 이벤트를 발행할 수 있습니다.
이벤트로는 `ReservationSuccessEvent` 로 이벤트를 만들어서 예약완료 이벤트를 만들어 보겠습니다.

```kotlin

```

### EventListener / TransactionalEventListener



#### `@TransactionalEventListener`

`@TransactionalEventListener` 의 경우에는 Publisher 쪽의 트랜잭션에 따라 리스너의 로직을 컨트롤 할 수 있습니다.

- `BEFORE_COMMIT` : 트랜잭션이 커밋되기 전에 이벤트를 처리합니다.
- `AFTER_COMMIT` : 트랜잭션이 성공적으로 커밋된 후에 이벤트를 처리합니다. 이 단계는 데이터베이스 상태가 확정되었음을 보장합니다.
- `AFTER_ROLLBACK` : 트랜잭션이 롤백된 후에 이벤트를 처리합니다.
- `AFTER_COMPLETION` : 트랜잭션이 완료된 후(성공이든 실패든) 에 이벤트를 처리합니다.

아래 순서는 `@TransactionalEventListener` 가 이벤트를 받았을때 각 옵션에 따른 동작 방식 입니다.

```text
1. 이벤트 발행
2. EventListener 중 처리가능한게 있으면, 돌면서 실행시킴
3. 커밋 직전 ( 위에 다 성공했음 )
4. BEFORE_COMMIT 중 처리가능한게 있으면, 돌면서 실행시킴
5. 커밋
6. AFTER_COMMIT 중 처리가능한게 있으면, 돌면서 실행시킴
7. 트랜잭션 종료
8. AFTER_COMPLETION 중 처리가능한게 있으면, 돌면서 실행시킴

번외
1. 롤백
2. AFTER_ROLLBACK 중 처리가능한게 있으면서, 돌면서 실행시킴
3. 트랜잭션 종료
4. AFTER_COMPLETION 중 처리가능한게 있으면, 돌면서 실행시킴
```

만약 `@TransactionalEventListener` 에서 `@Transactional` 이 없다면 어떻게 동작할까요??

**정답은 이벤트 리스터가 동작을 하지 않습니다.** 트랜잭션에 따라 동작하는 방식이 다르기 때문에 트랜잭션이 없으면 이벤트 리스터가 정상적으로 동작하지 않습니다.

또 다른 질문으로 `@EventListener` 와 `@TransactionalEventListener` 를 같이 사용하면 어떻게 동작할까요??